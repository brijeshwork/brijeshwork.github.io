<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>How to Design a Cloud Storage System (AWS S3, GCP, Azure) — System Design | Brijesh Patel</title>
<meta name="description" content="Cloud storage system design: object storage patterns, consistency, durability, partitioning and lifecycle management.">
<link rel="canonical" href="https://brijesh.work/system-design/cloud-storage-system-design/" />
<link rel="stylesheet" href="https://brijesh.work/pub/css/bootstrap.css">
<link rel="stylesheet" href="https://brijesh.work/pub/css/style-main.css">
<script src="https://brijesh.work/pub/js/global.js" crossorigin="anonymous"></script>
</head>
<body>
<header loadhtml="https://brijesh.work/pub/inc/header.html" class="header"></header>

<section>
  <div class="container">
    <div class="row">
      <div class="col-12 col-lg-8">
        <h1>How to Design a Cloud Storage System (AWS S3, GCP, Azure)</h1>
        <p class="lead">Designing a durable, scalable object storage service with considerations for consistency, metadata, and cost.</p>

        <h2 id="requirements">Requirements</h2>
        <ul>
          <li>High durability and availability</li>
          <li>Scalable to billions of objects and large payloads</li>
          <li>Metadata indexing and efficient listing</li>
          <li>Access control and lifecycle policies</li>
        </ul>

        <h3 id="design-sketch">Design sketch</h3>
        <p>Partition by object key prefixes, store object data in chunked storage with erasure coding, and keep small metadata in a highly-available metadata store (Dynamo-style). Use CDNs for hot objects.</p>

        <!-- Architecture diagram -->
        <div class="mb-4">
          <svg width="100%" height="180" viewBox="0 0 900 180" xmlns="http://www.w3.org/2000/svg" role="img" aria-label="Cloud storage architecture">
            <defs>
              <style>.b{fill:#f8f9fa;stroke:#adb5bd;stroke-width:1}.l{font-size:12px;fill:#212529}</style>
            </defs>
            <rect x="20" y="20" width="200" height="120" class="b" rx="6"/>
            <text x="120" y="50" text-anchor="middle" class="l">Clients</text>
            <text x="120" y="70" text-anchor="middle" class="l">(PUT/GET/ LIST)</text>

            <rect x="250" y="10" width="260" height="160" class="b" rx="6"/>
            <text x="380" y="40" text-anchor="middle" class="l">Frontend / API Layer</text>
            <text x="380" y="60" text-anchor="middle" class="l">Auth, ACLs, Upload orchestration</text>

            <rect x="540" y="20" width="320" height="120" class="b" rx="6"/>
            <text x="700" y="50" text-anchor="middle" class="l">Storage Cluster</text>
            <text x="700" y="70" text-anchor="middle" class="l">Chunk store, Erasure coding, Object index</text>

            <path d="M220 80 L250 80" stroke="#495057" stroke-width="2" marker-end="url(#m)"/>
            <path d="M510 80 L540 80" stroke="#495057" stroke-width="2" marker-end="url(#m)"/>
            <defs><marker id="m" markerWidth="10" markerHeight="7" refX="10" refY="3.5" orient="auto"><polygon points="0 0,10 3.5,0 7" fill="#495057"/></marker></defs>
          </svg>
          <p class="small text-muted">Figure: Client → API layer (auth, multipart orchestration) → storage cluster (chunking + erasure coding + metadata index).</p>
        </div>

        <h3 id="partitioning">Partitioning & key design</h3>
        <p>Design object keys to ensure even distribution. Common techniques:</p>
        <ul>
          <li>Hash prefixes: shard by hash(object_key) &lt;&lt; N to distribute objects across partitions.</li>
          <li>Bucket + date: use logical buckets and time prefixes for efficient life-cycle operations.</li>
          <li>Consistent hashing for node membership changes to minimize reshuffle.</li>
        </ul>

        <h3 id="erasure-coding">Erasure coding vs replication</h3>
        <p>Erasure coding (e.g., Reed-Solomon) reduces storage overhead compared to full replication while providing durability. Typical parameters: RS(k=6, m=3) stores 6 data shards + 3 parity shards.</p>
        <p>Trade-offs:</p>
        <ul>
          <li>Encoding/decoding CPU cost vs storage savings.</li>
          <li>Reconstruction read amplification (need to fetch k shards to rebuild).</li>
          <li>Good for cold or bulk storage; replication may be used for frequently-read hot objects.</li>
        </ul>

        <h3 id="metadata-model">Metadata model (example)</h3>
        <p>Keep small metadata in a highly-available key-value store for fast lookups. Example record:</p>
        <pre><code class="language-json">{
  "object_key": "photos/2025/10/27/image-12345.jpg",
  "bucket": "user-uploads",
  "size": 5242880,
  "content_type": "image/jpeg",
  "created_at": "2025-10-27T10:15:00Z",
  "chunk_locations": [
    {"shard_id":"s1","node":"node-3","offset":0},
    {"shard_id":"s2","node":"node-9","offset":0}
  ],
  "acl": "private",
  "tags": {"user":"123","album":"summer"}
}
</code></pre>

        <h3 id="multipart-upload">Multipart upload flow (simplified)</h3>
        <ol>
          <li>Client calls POST /{bucket}/{key}?uploads to start and gets an uploadId.</li>
          <li>Client uploads parts: PUT /{bucket}/{key}?partNumber=X&uploadId=ID</li>
          <li>Server stores each part as temporary objects (or directly as chunks in the chunk store).</li>
          <li>Client calls CompleteUpload with list of parts; server composes final object, runs erasure-coding and writes metadata.</li>
        </ol>

        <pre><code class="language-bash"># example: start upload (pseudo)
curl -X POST https://storage.example.com/user-uploads/photos/2025/10/27/image-12345.jpg?uploads \
  -H "Authorization: Bearer $TOKEN"
# returns uploadId=abc123
</code></pre>

        <h3 id="lifecycle">Lifecycle policies & cost management</h3>
        <p>Use lifecycle rules to move objects to colder storage (or delete) after a defined TTL.</p>
        <pre><code class="language-json">{
  "Rules": [
    {"ID": "expire-30-days", "Prefix": "tmp/", "Status": "Enabled", "Expiration": {"Days": 30}},
    {"ID": "transition-cold", "Prefix": "archives/", "Status": "Enabled", "Transition": {"Days": 90, "StorageClass": "GLACIER"}}
  ]
}
</code></pre>

        <h3 id="consistency">Consistency and listing</h3>
        <p>Object storage often offers eventual consistency for listing and metadata updates while providing strong read-after-write for new objects in many systems — document your service guarantees and design clients to handle eventual consistency for listings.</p>

        <h2 id="conclusion">Conclusion</h2>
        <p>Design object stores with a separation of concerns: fast metadata/index for lookups, chunked durable storage for payloads, and a CDN layer for hot reads. Choose erasure coding parameters and partitioning strategies based on access patterns and cost targets.</p>

        <!-- Prism.js for code highlighting -->
        <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/themes/prism.min.css" rel="stylesheet">
        <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/components/prism-core.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/autoloader/prism-autoloader.min.js"></script>

        <h2 id="conclusion">Conclusion</h2>
        <p>Object storage systems trade consistency for availability and scale; choose design patterns based on access patterns and SLAs.</p>
      </div>

      <aside class="col-12 col-lg-4">
        <div class="card mb-4"><div class="card-body"><h5>Quick links</h5><ul class="list-unstyled"><li><a href="#requirements">Requirements</a></li><li><a href="#design-sketch">Design sketch</a></li></ul></div></div>
      </aside>
    </div>
  </div>
</section>

<footer loadhtml="https://brijesh.work/pub/inc/footer.html"></footer>
<script src="https://brijesh.work/pub/js/footer.js" crossorigin="anonymous"></script>
<script>includeHTML();</script>
</body>
</html>
