<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">    
<title>Rate Limiting — System Design | Brijesh Patel</title>
<meta name="description" content="System design for a scalable rate limiting service: token bucket, sliding window, Redis counters, API Gateway integration, and distributed coordination patterns.">
<meta name="author" content="Brijesh Patel">
<link rel="canonical" href="https://brijesh.work/system-design/rate-limiting/" />
<meta property="og:locale" content="en_US" />
<meta property="og:type" content="article" />
<meta property="og:title" content="Rate Limiting — System Design" />
<meta property="og:description" content="Design patterns and operational guidance for building a production-ready, scalable rate limiting system using token buckets, Redis, and API gateways." />
<meta property="og:url" content="https://brijesh.work/system-design/rate-limiting/" />
<meta property="og:site_name" content="Brijesh Patel - System Design" />
<meta property="og:image" content="https://brijesh.work/system-design/rate-limiting/rate-limiting-architecture.png" />
<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:creator" content="@brijeshwork" />

<link rel="stylesheet" href="https://brijesh.work/pub/css/bootstrap.css">
<link rel="stylesheet" href="https://brijesh.work/pub/css/style-main.css">
<script src="https://brijesh.work/pub/js/global.js" crossorigin="anonymous"></script>

</head>
<body>
<header loadhtml="https://brijesh.work/pub/inc/header.html" class="header"></header>

<section>
  <div class="container">
    <div class="row">
      <div class="col-12 col-lg-8">
        <h1>Rate Limiting — System Design</h1>
        <p class="lead">Building a production-ready, scalable rate limiting service that protects APIs and downstream systems from abuse while providing predictable experience for legitimate users.</p>

        <h2 id="overview">Overview</h2>
        <p>Rate limiting enforces usage policies by throttling requests. Typical deployment points are API gateways, edge proxies, or application services. We'll cover requirements, patterns, and trade-offs for an internet-scale rate limiting system.</p>

        <h3 id="requirements">Requirements</h3>
        <ul>
          <li>Enforce per-API-key and per-IP rate limits (e.g. 100 req/min per user, 1000 req/min per IP)</li>
          <li>Low request-latency (target &lt;2ms extra for lookup)</li>
          <li>Strong accuracy for small windows (short bursts) and eventual consistency for aggregated metrics</li>
          <li>Highly available and horizontally scalable</li>
          <li>Configurable policies and real-time updates</li>
        </ul>

        <h3 id="constraints">Constraints</h3>
        <ul>
          <li>High QPS at the edge (tens to hundreds of thousands per second)</li>
          <li>Latency sensitivity — rate check must be in the request path</li>
          <li>Limited memory per node, need for compact counters</li>
        </ul>

        <h2 id="high-level">High-level Design</h2>
        <p>At a high level, an API Gateway / Edge will consult a distributed rate limiting store to decide whether to accept or reject requests. Common components:</p>
        <ol>
          <li>API Gateway / Edge Proxy (Nginx, Envoy)</li>
          <li>Rate Limiter Service (stateless, optionally with local cache)</li>
          <li>Shared datastore for counters (Redis cluster, consistent hashing)</li>
          <li>Configuration service for policies</li>
          <li>Telemetry pipeline (metrics, logging)</li>
        </ol>

        <h3 id="algorithms">Algorithms</h3>
        <h4>Token Bucket</h4>
        <p>Token bucket supports bursts: tokens are added at fixed rate and consumed per request. Implemented using an atomic Lua script in Redis or in-process with periodic refill for local caches.</p>

        <h4>Sliding Window Counter</h4>
        <p>Sliding window maintains high accuracy for small windows by storing per-subwindow counters (e.g., per second). It is more accurate than fixed window but slightly more complex and memory intensive.</p>

        <h4>Leaky Bucket</h4>
        <p>Leaky bucket smooths bursts by queuing requests at a fixed drain rate. Use when you need strict smoothing behaviour.</p>

        <h2 id="data-model">Data model & storage</h2>
        <p>Use compact keys like <code>rl:u:{user_id}:{window_start}</code> and store integer counters. For token bucket store: last_refill_timestamp and tokens_remaining. Redis Hashes or single keys with Lua scripts work well.</p>

        <h3 id="redis-patterns">Redis patterns</h3>
        <ul>
          <li>Atomic increments via INCR/INCRBY for fixed window counters</li>
          <li>Lua scripts for read-modify-write in token bucket (check refill, consume)</li>
          <li>Use TTLs on keys to expire old windows automatically</li>
          <li>Cluster with consistent hashing for sharding high-cardinality keys</li>
        </ul>

        <h2 id="scaling">Scaling & performance</h2>
        <ul>
          <li>Local Cache: shadow counters in edge nodes for ultra-low latency with periodic flush to Redis (trade accuracy)</li>
          <li>Sharding: shard keys by API token hash to distribute load across Redis nodes</li>
          <li>Batching: batch counter writes where acceptable to reduce Redis write QPS</li>
          <li>Use pipelining or Lua to minimize round-trips</li>
        </ul>

        <h3 id="availability">Availability and fault tolerance</h3>
        <ul>
          <li>Use Redis Cluster with replicas for read availability and fast failover</li>
          <li>Fallback behaviors: if datastore is unavailable, either allow requests safely (fail-open) or reject (fail-closed) depending on safety requirements</li>
          <li>Graceful degradation: relax limits or increase TTLs when under degraded mode</li>
        </ul>

        <h2 id="policy-management">Policy Management</h2>
        <p>Policies should be centrally managed and pushed to edge nodes via a configuration service or via a pub/sub channel. Use versioned policies and support hot reloads without restart.</p>

        <h2 id="tradeoffs">Trade-offs</h2>
        <ul>
          <li>Accuracy vs latency: local caching reduces latency but increases chance of overshoot</li>
          <li>Simplicity vs memory: sliding windows use more memory but are more precise</li>
          <li>Consistency vs availability: stronger consistency requires synchronous coordination</li>
        </ul>

        <h2 id="implementation">Implementation Example (Redis + Lua)</h2>
        <pre><code class="language-lua">-- token bucket Lua sketch (simplified)
local key = KEYS[1]
local rate = tonumber(ARGV[1]) -- tokens per second
local capacity = tonumber(ARGV[2])
local now = tonumber(ARGV[3])
local requested = tonumber(ARGV[4])

local data = redis.call('HMGET', key, 'tokens', 'ts')
local tokens = tonumber(data[1]) or capacity
local ts = tonumber(data[2]) or now

-- refill
local delta = math.max(0, now - ts)
local filled = math.min(capacity, tokens + delta * rate)
if filled < requested then
  return 0
else
  filled = filled - requested
  redis.call('HMSET', key, 'tokens', filled, 'ts', now)
  redis.call('EXPIRE', key, 3600)
  return 1
end</code></pre>

        <h2 id="monitoring">Monitoring & Metrics</h2>
        <ul>
          <li>Per-key request rate, rejection rate, and error rate</li>
          <li>Redis latency and error metrics</li>
          <li>Alerts for sudden increase in rejects or key spikes</li>
        </ul>

        <h2 id="conclusion">Conclusion</h2>
        <p>Rate limiting at scale requires balancing accuracy, latency, and availability. For most use-cases, Redis-based token bucket via Lua scripts offers a good balance. For extreme scale, combine edge caching with a strong centralized store and careful sharding.</p>

      </div>

      <aside class="col-12 col-lg-4">
        <div class="card mb-4">
          <div class="card-body">
            <h5>Quick links</h5>
            <ul class="list-unstyled">
              <li><a href="#overview">Overview</a></li>
              <li><a href="#requirements">Requirements</a></li>
              <li><a href="#high-level">High-level Design</a></li>
              <li><a href="#algorithms">Algorithms</a></li>
              <li><a href="#implementation">Implementation Example</a></li>
            </ul>
          </div>
        </div>

        <div class="card">
          <div class="card-body">
            <h6>Resources</h6>
            <ul class="list-unstyled">
              <li><a href="https://redis.io/docs/" target="_blank" rel="noopener">Redis</a></li>
              <li><a href="https://envoyproxy.io/docs/" target="_blank" rel="noopener">Envoy</a></li>
              <li><a href="https://developer.akamai.com/" target="_blank" rel="noopener">Akamai Docs</a></li>
            </ul>
          </div>
        </div>
      </aside>
    </div>
  </div>
</section>
https://www.youtube.com/watch?v=CVItTb_jdkE
https://www.youtube.com/watch?v=eR66m7TaV5A

<footer loadhtml="https://brijesh.work/pub/inc/footer.html"></footer>
<script src="https://brijesh.work/pub/js/footer.js" crossorigin="anonymous"></script>

<!-- Prism.js for syntax highlighting -->
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/themes/prism.min.css" rel="stylesheet">
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/components/prism-core.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/autoloader/prism-autoloader.min.js"></script>

<script>
// Smooth scrolling and active link highlight (copied from notification page)
document.addEventListener('DOMContentLoaded', function() {
    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener('click', function (e) {
            e.preventDefault();
            const target = document.querySelector(this.getAttribute('href'));
            if (target) {
                target.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }
        });
    });

    window.addEventListener('scroll', function() {
        let current = '';
        const sections = document.querySelectorAll('section[id], h2[id], h3[id]');
        sections.forEach(section => {
            const sectionTop = section.offsetTop;
            if (scrollY >= (sectionTop - 200)) {
                current = section.getAttribute('id');
            }
        });

        document.querySelectorAll('#sidebar .nav-link').forEach(link => {
            link.classList.remove('active');
            if (link.getAttribute('href') === '#' + current) {
                link.classList.add('active');
            }
        });
    });
});
</script>

<script>includeHTML();</script>
</body>
</html>
