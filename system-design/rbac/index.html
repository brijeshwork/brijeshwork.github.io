<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>RBAC (Role-Based Access Control) Complete Guide | Patterns, Implementation & Best Practices</title>
  <meta name="description"
    content="Complete guide to Role-Based Access Control (RBAC): models, implementation patterns, hierarchy, caching strategies, enforcement points, RBAC vs ABAC comparison, and Python code examples.">
  <meta name="keywords"
    content="RBAC, role-based access control, authorization, permissions, roles, access control, security, ABAC, policy management">
  <meta name="author" content="Brijesh Patel">
  <link rel="canonical" href="https://brijesh.work/system-design/rbac/" />

  <!-- Styles -->
  <link rel="stylesheet" href="https://brijesh.work/pub/css/bootstrap.css">
  <link rel="stylesheet" href="https://brijesh.work/pub/css/style-main.css">
  <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
  <script src="https://brijesh.work/pub/js/global.js" crossorigin="anonymous"></script>

  <style>
    /* Custom styles matching other system design pages */
    .hero-section {
      background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
      color: white;
      padding: 4rem 0;
      margin-bottom: 2rem;
    }

    .hero-subtitle {
      color: #94a3b8;
      font-size: 1.25rem;
    }

    .sidebar-sticky {
      position: sticky;
      top: 2rem;
    }

    .sidebar-toc .nav-link {
      color: #64748b;
      padding: 0.25rem 0;
      font-size: 0.95rem;
    }

    .sidebar-toc .nav-link:hover,
    .sidebar-toc .nav-link.active {
      color: #0d6efd;
      font-weight: 500;
    }

    .content-section {
      margin-bottom: 3rem;
    }

    .tech-card {
      border: 1px solid #e2e8f0;
      border-radius: 0.5rem;
      padding: 1.5rem;
      height: 100%;
      background: #f8fafc;
      transition: transform 0.2s;
    }

    .tech-card:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
    }

    .comparison-table th {
      background-color: #f1f5f9;
    }

    .badge-soft {
      background-color: rgba(13, 110, 253, 0.1);
      color: #0d6efd;
      padding: 0.5em 0.8em;
    }

    .model-card {
      border-left: 4px solid #0d6efd;
      background: #f8fafc;
      padding: 1.5rem;
      margin-bottom: 1.5rem;
      border-radius: 0.5rem;
    }

    @media (max-width: 991px) {
      .order-lg-1 {
        order: 2;
      }

      .order-lg-2 {
        order: 1;
      }
    }
  </style>
</head>

<body class="bg-white">

  <header loadhtml="https://brijesh.work/pub/inc/header.html" class="header border-bottom"></header>

  <!-- Hero Section -->
  <section class="hero-section">
    <div class="container">
      <div class="row">
        <div class="col-lg-8">
          <span
            class="badge badge-soft mb-3 rounded-pill bg-primary bg-opacity-25 text-white border border-white border-opacity-25">Authorization
            Pattern</span>
          <h1 class="display-4 fw-bold mb-3">Role-Based Access Control (RBAC)</h1>
          <p class="hero-subtitle mb-4">Master RBAC patterns for secure, scalable authorization. Learn role hierarchies,
            permission management, enforcement strategies, and implementation best practices.</p>
          <div class="d-flex gap-3">
            <a href="#implementation" class="btn btn-primary">Implementation Guide</a>
            <a href="#comparison" class="btn btn-outline-light">RBAC vs ABAC</a>
          </div>
        </div>
      </div>
    </div>
  </section>

  <div class="container pb-5">
    <div class="row">

      <!-- Main Content -->
      <main class="col-lg-9 order-lg-2">

        <!-- Introduction -->
        <section id="introduction" class="content-section">
          <h2>What is RBAC?</h2>
          <p class="lead text-secondary">Role-Based Access Control grants permissions based on roles assigned to users,
            simplifying permission management at scale.</p>
          <p>RBAC is the most widely adopted authorization model in enterprise systems. Instead of assigning permissions
            directly to individual users, you:</p>
          <ol>
            <li>Define <strong>Roles</strong> (e.g., Admin, Editor, Viewer)</li>
            <li>Assign <strong>Permissions</strong> to roles (e.g., "read:articles", "write:articles", "delete:users")
            </li>
            <li>Assign <strong>Users</strong> to roles</li>
          </ol>

          <div class="alert alert-light border mt-3">
            <strong>Key Principle:</strong> Users → Roles → Permissions. Permissions are never assigned directly to
            users,
            only through roles.
          </div>

          <h4 class="mt-4">Why RBAC?</h4>
          <ul>
            <li><strong>Simplified Management:</strong> Change role permissions once, affect all users with that role
            </li>
            <li><strong>Least Privilege:</strong> Grant minimum necessary permissions through role membership</li>
            <li><strong>Auditing:</strong> Easily answer "Who has access to X?" by checking role membership</li>
            <li><strong>Compliance:</strong> Map organizational job functions to roles for SOX, HIPAA, etc</li>
            <li><strong>Scalability:</strong> Manage millions of users with dozens of roles</li>
          </ul>
        </section>

        <!-- RBAC Models -->
        <section id="models" class="content-section">
          <h2>RBAC Models</h2>
          <p>RBAC has evolved into several models with increasing complexity and flexibility.</p>

          <div class="model-card">
            <h4>1. Flat RBAC (Core RBAC)</h4>
            <p><strong>Structure:</strong> Users → Roles → Permissions (simple many-to-many relationships)</p>
            <p><strong>Example:</strong> A "Blog Editor" role has permissions: <code>read:posts</code>,
              <code>write:posts</code>, <code>publish:posts</code>
            </p>
            <p class="mb-0"><strong>Best for:</strong> Simple applications with clear role boundaries</p>
          </div>

          <div class="model-card">
            <h4>2. Hierarchical RBAC</h4>
            <p><strong>Structure:</strong> Roles can inherit permissions from parent roles</p>
            <p><strong>Example:</strong> <code>Admin</code> inherits all permissions from <code>Editor</code>, which
              inherits from <code>Viewer</code></p>
            <p><strong>Benefit:</strong> Reduces duplication. Define base permissions once, extend with additional
              permissions</p>
            <p class="mb-0"><strong>Best for:</strong> Organizations with clear hierarchies (Manager > Employee > Guest)
            </p>
          </div>

          <div class="model-card">
            <h4>3. Constrained RBAC</h4>
            <p><strong>Feature:</strong> Add constraints like "mutually exclusive roles" (separation of duties)</p>
            <p><strong>Example:</strong> A user cannot be both "Purchaser" and "Approver" (prevents self-approval fraud)
            </p>
            <p class="mb-0"><strong>Best for:</strong> Financial systems, compliance-heavy industries</p>
          </div>

          <div class="model-card">
            <h4>4. Hybrid RBAC + ABAC</h4>
            <p><strong>Combine:</strong> Role membership + dynamic attributes for fine-grained control</p>
            <p><strong>Example:</strong> Role "Editor" + condition "resource.owner == user.id" allows editing only own
              content</p>
            <p class="mb-0"><strong>Best for:</strong> Multi-tenant systems, resource-level permissions</p>
          </div>
        </section>

        <!-- Data Model -->
        <section id="data-model" class="content-section">
          <h2>Data Model & Schema</h2>
          <p>A typical relational database schema for RBAC with role hierarchy support.</p>

          <h4 class="mt-4">Core Tables</h4>
          <pre><code class="language-sql">-- Users table
CREATE TABLE users (
  id UUID PRIMARY KEY,
  username VARCHAR(255) UNIQUE NOT NULL,
  email VARCHAR(255) UNIQUE NOT NULL,
  created_at TIMESTAMP DEFAULT NOW()
);

-- Roles table
CREATE TABLE roles (
  id UUID PRIMARY KEY,
  name VARCHAR(100) UNIQUE NOT NULL,
  description TEXT,
  created_at TIMESTAMP DEFAULT NOW()
);

-- Permissions table
CREATE TABLE permissions (
  id UUID PRIMARY KEY,
  name VARCHAR(100) UNIQUE NOT NULL,  -- e.g., "read:articles", "delete:users"
  description TEXT,
  resource VARCHAR(100),  -- e.g., "articles", "users"
  action VARCHAR(50)      -- e.g., "read", "write", "delete"
);

-- User-Role assignments (many-to-many)
CREATE TABLE user_roles (
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  role_id UUID REFERENCES roles(id) ON DELETE CASCADE,
  assigned_at TIMESTAMP DEFAULT NOW(),
  assigned_by UUID REFERENCES users(id),
  PRIMARY KEY (user_id, role_id)
);

-- Role-Permission assignments (many-to-many)
CREATE TABLE role_permissions (
  role_id UUID REFERENCES roles(id) ON DELETE CASCADE,
  permission_id UUID REFERENCES permissions(id) ON DELETE CASCADE,
  granted_at TIMESTAMP DEFAULT NOW(),
  PRIMARY KEY (role_id, permission_id)
);

-- Role hierarchy (for hierarchical RBAC)
CREATE TABLE role_hierarchy (
  parent_role_id UUID REFERENCES roles(id) ON DELETE CASCADE,
  child_role_id UUID REFERENCES roles(id) ON DELETE CASCADE,
  PRIMARY KEY (parent_role_id, child_role_id),
  CHECK (parent_role_id != child_role_id)  -- Prevent self-reference
);

-- Indexes for performance
CREATE INDEX idx_user_roles_user ON user_roles(user_id);
CREATE INDEX idx_role_permissions_role ON role_permissions(role_id);
</code></pre>
        </section>

        <!-- Implementation -->
        <section id="implementation" class="content-section">
          <h2>Implementation in Python</h2>
          <p>A production-ready RBAC system with role hierarchy and caching.</p>

          <h4 class="mt-4">RBAC Service Class</h4>
          <pre><code class="language-python">import redis
import json
from typing import Set, List, Optional
from dataclasses import dataclass

@dataclass
class Permission:
    name: str
    resource: str
    action: str

class RBACService:
    def __init__(self, db_connection, redis_client=None):
        self.db = db_connection
        self.cache = redis_client or redis.StrictRedis(decode_responses=True)
        self.cache_ttl = 3600  # 1 hour
    
    def check_permission(self, user_id: str, permission_name: str) -> bool:
        """
        Check if user has a specific permission (through any of their roles).
        Uses caching for performance.
        """
        # Try cache first
        cache_key = f"user_permissions:{user_id}"
        cached_permissions = self.cache.get(cache_key)
        
        if cached_permissions:
            permissions = json.loads(cached_permissions)
            return permission_name in permissions
        
        # Cache miss - query database
        permissions = self.get_user_permissions(user_id)
        
        # Store in cache
        self.cache.setex(
            cache_key,
            self.cache_ttl,
            json.dumps(list(permissions))
        )
        
        return permission_name in permissions
    
    def get_user_permissions(self, user_id: str) -> Set[str]:
        """
        Get all effective permissions for a user (including inherited permissions).
        """
        query = """
        WITH RECURSIVE role_tree AS (
          -- Base: user's direct roles
          SELECT ur.role_id
          FROM user_roles ur
          WHERE ur.user_id = %s
          
          UNION
          
          -- Recursive: inherited roles
          SELECT rh.parent_role_id
          FROM role_hierarchy rh
          INNER JOIN role_tree rt ON rt.role_id = rh.child_role_id
        )
        SELECT DISTINCT p.name
        FROM permissions p
        INNER JOIN role_permissions rp ON rp.permission_id = p.id
        INNER JOIN role_tree rt ON rt.role_id = rp.role_id
        """
        
        cursor = self.db.cursor()
        cursor.execute(query, (user_id,))
        permissions = {row[0] for row in cursor.fetchall()}
        cursor.close()
        
        return permissions
    
    def assign_role(self, user_id: str, role_id: str, assigned_by: str):
        """Assign a role to a user and invalidate cache."""
        query = """
        INSERT INTO user_roles (user_id, role_id, assigned_by)
        VALUES (%s, %s, %s)
        ON CONFLICT (user_id, role_id) DO NOTHING
        """
        cursor = self.db.cursor()
        cursor.execute(query, (user_id, role_id, assigned_by))
        self.db.commit()
        cursor.close()
        
        # Invalidate user permission cache
        self.cache.delete(f"user_permissions:{user_id}")
    
    def revoke_role(self, user_id: str, role_id: str):
        """Revoke a role from a user and invalidate cache."""
        query = "DELETE FROM user_roles WHERE user_id = %s AND role_id = %s"
        cursor = self.db.cursor()
        cursor.execute(query, (user_id, role_id))
        self.db.commit()
        cursor.close()
        
        # Invalidate cache
        self.cache.delete(f"user_permissions:{user_id}")
    
    def has_role(self, user_id: str, role_name: str) -> bool:
        """Check if user has a specific role."""
        query = """
        SELECT 1
        FROM user_roles ur
        INNER JOIN roles r ON r.id = ur.role_id
        WHERE ur.user_id = %s AND r.name = %s
        """
        cursor = self.db.cursor()
        cursor.execute(query, (user_id, role_name))
        result = cursor.fetchone() is not None
        cursor.close()
        return result

# Usage Example
rbac = RBACService(db_connection, redis_client)

# Check permission
if rbac.check_permission(user_id="123", permission_name="delete:users"):
    # User can delete users
    pass

# Assign role
rbac.assign_role(
    user_id="123",
    role_id="admin-role-uuid",
    assigned_by="super-admin-uuid"
)
</code></pre>

          <h4 class="mt-4">Decorator for Route Protection (Flask)</h4>
          <pre><code class="language-python">from functools import wraps
from flask import request, jsonify, g

rbac = RBACService(db, redis_client)

def require_permission(permission_name: str):
    """Decorator to enforce permission checks on routes."""
    def decorator(f):
        @wraps(f)
        def wrapper(*args, **kwargs):
            # Assume user_id is set by authentication middleware
            user_id = g.get('user_id')
            if not user_id:
                return jsonify({"error": "Unauthorized"}), 401
            
            if not rbac.check_permission(user_id, permission_name):
                return jsonify({
                    "error": "Forbidden",
                    "message": f"Required permission: {permission_name}"
                }), 403
            
            return f(*args, **kwargs)
        return wrapper
    return decorator

# Usage in routes
@app.route('/admin/users', methods=['DELETE'])
@require_permission('delete:users')
def delete_user():
    # Only users with "delete:users" permission can execute this
    return jsonify({"message": "User deleted"})

@app.route('/articles/<article_id>', methods=['PUT'])
@require_permission('write:articles')
def update_article(article_id):
    return jsonify({"message": "Article updated"})
</code></pre>
        </section>

        <!-- Enforcement Points -->
        <section id="enforcement" class="content-section">
          <h2>Enforcement Points</h2>
          <p>Where to check permissions in your application architecture.</p>

          <div class="row">
            <div class="col-md-6">
              <div class="tech-card">
                <h6 class="fw-bold">1. API Gateway / Edge</h6>
                <p class="small">Coarse-grained checks before requests reach backend services. Blocks unauthorized users
                  early.</p>
                <p class="small text-muted mb-0">Example: Block all non-admin requests to <code>/admin/*</code></p>
              </div>
            </div>
            <div class="col-md-6">
              <div class="tech-card">
                <h6 class="fw-bold">2. Service Layer</h6>
                <p class="small">Fine-grained checks within business logic. Closest to data, most accurate.</p>
                <p class="small text-muted mb-0">Example: Check if user can edit this specific article</p>
              </div>
            </div>
            <div class="col-md-6">
              <div class="tech-card">
                <h6 class="fw-bold">3. Database Level</h6>
                <p class="small">Row-Level Security (RLS) in PostgreSQL for per-row access control.</p>
                <p class="small text-muted mb-0">Example: Users only see rows where <code>user_id = current_user</code>
                </p>
              </div>
            </div>
            <div class="col-md-6">
              <div class="tech-card">
                <h6 class="fw-bold">4. UI/Frontend</h6>
                <p class="small">Hide UI elements user cannot access (buttons, menu items). Never rely on this alone!
                </p>
                <p class="small text-muted mb-0">Example: Hide "Delete" button for Viewer role</p>
              </div>
            </div>
          </div>

          <div class="alert alert-warning border mt-3">
            <strong>⚠️ Defense in Depth:</strong> Always enforce at multiple layers. Frontend hiding is UX, NOT
            security.
            Backend must always validate.
          </div>
        </section>

        <!-- RBAC vs ABAC -->
        <section id="comparison" class="content-section">
          <h2>RBAC vs ABAC Comparison</h2>
          <p>RBAC (Role-Based) vs ABAC (Attribute-Based) Access Control—when to use each.</p>

          <div class="table-responsive mt-3">
            <table class="table table-bordered comparison-table">
              <thead>
                <tr>
                  <th style="width: 20%">Dimension</th>
                  <th style="width: 40%">RBAC</th>
                  <th style="width: 40%">ABAC</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td><strong>Access Decision</strong></td>
                  <td>Based on user's role membership</td>
                  <td>Based on attributes (user, resource, environment)</td>
                </tr>
                <tr>
                  <td><strong>Flexibility</strong></td>
                  <td>Coarse-grained. Good for static org structures.</td>
                  <td>Fine-grained. Dynamic, context-aware policies.</td>
                </tr>
                <tr>
                  <td><strong>Complexity</strong></td>
                  <td>Simple to understand and implement.</td>
                  <td>Complex. Requires policy engine and attribute management.</td>
                </tr>
                <tr>
                  <td><strong>Performance</strong></td>
                  <td>Fast. Simple table lookups, easy to cache.</td>
                  <td>Slower. Requires policy evaluation at runtime.</td>
                </tr>
                <tr>
                  <td><strong>Management</strong></td>
                  <td>Easy for admins. Assign users to roles.</td>
                  <td>Harder. Define complex rules and attribute mappings.</td>
                </tr>
                <tr>
                  <td><strong>Example Rule</strong></td>
                  <td>"Editors can write articles"</td>
                  <td>"Users can edit articles if they are the author AND it's before 5pm AND article is not published"
                  </td>
                </tr>
                <tr>
                  <td><strong>Best For</strong></td>
                  <td>Enterprise apps, clear org hierarchies, static permissions</td>
                  <td>Multi-tenant SaaS, resource-level permissions, dynamic policies</td>
                </tr>
              </tbody>
            </table>
          </div>

          <div class="alert alert-light border mt-3">
            <strong>Recommendation:</strong> Start with RBAC. Add ABAC rules only when you need fine-grained,
            context-aware permissions that roles can't express.
          </div>
        </section>

        <!-- Scaling -->
        <section id="scaling" class="content-section">
          <h2>Scaling & Performance</h2>
          <p>Strategies to handle RBAC at scale with millions of users and billions of permission checks.</p>

          <h4 class="mt-4">1. Aggressive Caching</h4>
          <ul>
            <li><strong>Cache User Permissions:</strong> Precompute all effective permissions per user, cache in Redis
              with
              TTL</li>
            <li><strong>Cache Role Permissions:</strong> Cache role → permissions mapping (changes infrequently)</li>
            <li><strong>TTL Strategy:</strong> Short TTL (5-15 min) for critical roles, longer for regular users</li>
            <li><strong>Invalidation:</strong> On role assignment/revoke, delete user's permission cache key</li>
          </ul>

          <h4 class="mt-4">2. Precompute Role Hierarchies</h4>
          <p>For deep role hierarchies, precompute flattened permissions offline:</p>
          <pre><code class="language-python"># Offline job to flatten role hierarchies
def precompute_effective_permissions():
    """Run nightly to compute flattened role permissions."""
    for role in get_all_roles():
        permissions = compute_inherited_permissions(role.id)
        cache.setex(
            f"role_permissions:{role.id}",
            86400,  # 24 hours
            json.dumps(list(permissions))
        )
</code></pre>

          <h4 class="mt-4">3. Bloom Filters for Negative Checks</h4>
          <p>Use Bloom filters for quick "definitely does NOT have permission" checks:</p>
          <pre><code class="language-python">from pybloom_live import BloomFilter

def build_user_permission_bloom(user_id):
    permissions = get_user_permissions(user_id)
    bloom = BloomFilter(capacity=1000, error_rate=0.001)
    for perm in permissions:
        bloom.add(perm)
    return bloom

# Quick negative check
if permission not in user_bloom_filter:
    return False  # Definitely don't have permission
else:
    # Might have permission, check cache/DB
    return check_permission_in_cache(user_id, permission)
</code></pre>

          <h4 class="mt-4">4. Sharding by Tenant</h4>
          <p>For multi-tenant SaaS, shard RBAC data by tenant ID. Each tenant's roles/permissions in separate database
            or
            schema.</p>
        </section>

        <!-- Best Practices -->
        <section id="best-practices" class="content-section">
          <h2>Best Practices</h2>

          <h4 class="mt-4">Permission Naming Conventions</h4>
          <p>Use consistent, hierarchical naming:</p>
          <ul>
            <li><strong>Format:</strong> <code>action:resource</code> or <code>resource:action</code></li>
            <li><strong>Examples:</strong> <code>read:articles</code>, <code>write:users</code>,
              <code>delete:comments</code>
            </li>
            <li><strong>Wildcards:</strong> <code>*:articles</code> (all actions on articles),
              <code>admin:*</code> (all admin permissions)
            </li>
          </ul>

          <h4 class="mt-4">Role Design Guidelines</h4>
          <ul>
            <li>Keep roles <strong>coarse-grained</strong>. 10-50 roles, not 1000s</li>
            <li>Map roles to <strong>job functions</strong>, not individuals (e.g., "Content Editor", not "John's
              Special
              Role")</li>
            <li>Use <strong>composable roles</strong>. "Editor" + "Reviewer" instead of "Editor-Reviewer" mega-role</li>
            <li>Avoid <strong>role explosion</strong>. If you need hundreds of roles, consider ABAC for those cases</li>
          </ul>

          <h4 class="mt-4">Audit Everything</h4>
          <pre><code class="language-python"># Log all permission changes
def audit_role_assignment(user_id, role_id, assigned_by):
    audit_log = {
        "event": "role_assigned",
        "user_id": user_id,
        "role_id": role_id,
        "assigned_by": assigned_by,
        "timestamp": datetime.utcnow().isoformat()
    }
    # Send to audit log (append-only, immutable)
    append_to_audit_log(audit_log)
</code></pre>

          <h4 class="mt-4">Least Privilege Principle</h4>
          <ul>
            <li>Default deny: no permissions unless explicitly granted</li>
            <li>Time-bound roles: temporary elevated access with expiration</li>
            <li>Regular access reviews: audit who has what permissions quarterly</li>
          </ul>
        </section>

        <!-- Summary -->
        <section class="content-section border-top pt-5">
          <h2>Summary</h2>
          <ul>
            <li><strong>RBAC</strong> simplifies permission management by grouping permissions into roles.</li>
            <li>Use <strong>role hierarchies</strong> to avoid duplication and model org structures.</li>
            <li>Enforce permissions at <strong>multiple layers</strong>: API gateway, service, database.</li>
            <li><strong>Cache aggressively</strong>: precompute effective permissions, use Redis, invalidate on changes.
            </li>
            <li>RBAC is simpler than ABAC; start with RBAC, add ABAC only when needed.</li>
            <li>Follow <strong>least privilege</strong>, audit all changes, and use consistent naming conventions.</li>
            <li>For scale: cache permissions, flatten hierarchies offline, use Bloom filters for negative checks.</li>
          </ul>
        </section>

      </main>

      <!-- Sidebar (Left) -->
      <aside class="col-lg-3 order-lg-1 mb-4">
        <div class="sidebar-sticky">
          <h6 class="fw-bold text-uppercase text-secondary mb-3 small tracking-wide">On this page</h6>
          <nav class="nav flex-column sidebar-toc">
            <a class="nav-link" href="#introduction">Introduction</a>
            <a class="nav-link" href="#models">RBAC Models</a>
            <a class="nav-link" href="#data-model">Data Model</a>
            <a class="nav-link" href="#implementation">Python Implementation</a>
            <a class="nav-link" href="#enforcement">Enforcement Points</a>
            <a class="nav-link" href="#comparison">RBAC vs ABAC</a>
            <a class="nav-link" href="#scaling">Scaling & Performance</a>
            <a class="nav-link" href="#best-practices">Best Practices</a>
          </nav>

          <hr class="my-4">
          <h6 class="fw-bold text-secondary mb-3 small">Related Topics</h6>
          <ul class="list-unstyled small">
            <li class="mb-2"><a href="../secure-api-gateway/" class="text-decoration-none text-muted">Secure API
                Gateway</a></li>
            <li class="mb-2"><a href="../session-vs-token/" class="text-decoration-none text-muted">Session vs Token
                Auth</a></li>
            <li class="mb-2"><a href="../jwt-authentication/" class="text-decoration-none text-muted">JWT
                Authentication</a></li>
          </ul>
        </div>
      </aside>

    </div>
  </div>

  <footer loadhtml="https://brijesh.work/pub/inc/footer.html"></footer>
  <script src="https://brijesh.work/pub/js/footer.js" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-sql.min.js"></script>
  <script>includeHTML();</script>
</body>

</html>