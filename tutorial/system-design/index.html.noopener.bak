<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>System Design for Web Applications: Concepts, Patterns & Best Practices</title>
    <link rel="canonical" href="https://brijesh.work/tutorial/system-design/" />
    <meta name="description" content="A comprehensive guide to system design for web applications. Learn architecture, scalability, best practices, and interview tips for building robust, scalable systems.">
    <meta name="keywords" content="System Design, Web Application Architecture, Scalability, Design Patterns, Distributed Systems, System Design Interview, CDN, Microservices, Load Balancer, Caching, Database Sharding, API Gateway, Message Queue, Monitoring, Infrastructure as Code">

    <!-- Open Graph / Facebook -->
    <meta property="og:locale" content="en_US" />
    <meta property="og:type" content="article" />
    <meta property="og:title" content="System Design for Web Applications: Concepts, Patterns & Best Practices" />
    <meta property="og:description" content="A complete system design tutorial for web applications. Covers architecture, scalability, microservices, caching, databases, and more." />
    <meta property="og:url" content="https://brijesh.work/tutorial/system-design/" />
    <meta property="og:site_name" content="Brijesh Patel - Web Development Tutorials" />
    <meta property="og:image" content="https://brijesh.work/pub/media/images/system-design-tutorial.jpg" />
    <meta property="og:image:width" content="1200" />
    <meta property="og:image:height" content="630" />
    <meta property="og:image:type" content="image/jpeg" />
    <meta property="article:published_time" content="2024-01-01T08:00:00+00:00" />
    <meta property="article:modified_time" content="2024-06-01T08:00:00+00:00" />
    <meta property="article:author" content="Brijesh Patel" />
    <meta property="article:section" content="System Design" />
    <meta property="article:tag" content="System Design, Web Application, Architecture, Scalability, Microservices, CDN, Caching, Database, API, Monitoring" />

    <!-- Twitter -->
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:creator" content="@brijeshwork" />
    <meta name="twitter:title" content="System Design for Web Applications: Concepts, Patterns & Best Practices" />
    <meta name="twitter:description" content="A complete guide to system design for web applications. Learn architecture, scalability, microservices, caching, databases, and more." />
    <meta name="twitter:image" content="https://brijesh.work/pub/media/images/system-design-tutorial.jpg" />
    <meta name="twitter:label1" content="Written by" />
    <meta name="twitter:data1" content="Brijesh Patel" />
    <meta name="twitter:label2" content="Est. reading time" />
    <meta name="twitter:data2" content="20 minutes" />

    <link rel="apple-touch-icon" sizes="57x57" href="https://brijesh.work/pub/media/images/icon/apple-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="https://brijesh.work/pub/media/images/icon/apple-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="https://brijesh.work/pub/media/images/icon/apple-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="https://brijesh.work/pub/media/images/icon/apple-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="https://brijesh.work/pub/media/images/icon/apple-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="https://brijesh.work/pub/media/images/icon/apple-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="https://brijesh.work/pub/media/images/icon/apple-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="https://brijesh.work/pub/media/images/icon/apple-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="https://brijesh.work/pub/media/images/icon/apple-icon-180x180.png">
    <link rel="icon" type="image/png" sizes="192x192" href="https://brijesh.work/pub/media/images/icon/android-icon-192x192.png">
    <link rel="icon" type="image/png" sizes="32x32" href="https://brijesh.work/pub/media/images/icon/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="96x96" href="https://brijesh.work/pub/media/images/icon/favicon-96x96.png">
    <link rel="icon" type="image/png" sizes="16x16" href="https://brijesh.work/pub/media/images/icon/favicon-16x16.png">

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css">
    <link rel="stylesheet" href="https://brijesh.work/pub/css/style-main.css">
    <script src="https://brijesh.work/pub/js/global.js" crossorigin="anonymous"></script>
</head>
<body>
    <header loadhtml="https://brijesh.work/pub/inc/header.html" class="header shadow-sm bg-white" role="banner"></header>

    <main class="container py-5" role="main">
        <h1 class="section-title mb-4 text-primary">System Design for Web Applications: A Comprehensive Guide</h1>
        <div class="row g-4">
            <!-- Sidebar Navigation -->
            <aside class="col-12 col-lg-3 mb-4 mb-lg-0">
                <nav class="sticky-top" style="top: 6rem;">
                    <div class="card shadow-sm border-0">
                        <div class="card-body p-3">
                            <h5 class="card-title mb-3">Contents</h5>
                            <ul class="nav flex-column small">
                                <li class="nav-item"><a class="nav-link" href="#roadmap">Roadmap</a></li>
                                <li class="nav-item"><a class="nav-link" href="#core-principles">Core Principles</a></li>
                                <li class="nav-item"><a class="nav-link" href="#components">Components & Technologies</a></li>
                            </ul>
                        </div>
                    </div>
                </nav>
            </aside>
            <!-- Main Content -->
            <section class="col-12 col-lg-9">
                <article class="tutorial-section bg-white rounded shadow-sm p-4 mb-5">
                    <!-- Roadmap: From Basics to Advanced -->
                    <section id="roadmap" class="mb-5">
                        <h2 class="h4 mb-3 text-secondary">Roadmap: From Basics to Advanced</h2>
                        <ol class="ps-3">
                            <li>
                                <strong>Fundamentals:</strong>
                                <ul>
                                    <li>Start with the <b>client-server model</b>, basic networking (HTTP/TCP), and operating system concepts.</li>
                                    <li>Understand how requests flow from users to servers and back.</li>
                                    <li>Study <b>functional vs non-functional requirements</b> (e.g. scalability vs. performance).</li>
                                    <li>Learn about <b>latency vs throughput</b> trade-offs and the <b>CAP theorem</b> (consistency, availability, partition tolerance) as foundational concepts.
                                        <br>
                                        <a href="https://www.geeksforgeeks.org/tradeoffs-in-system-design/" target="_blank" rel="nofollow noreferrer">geeksforgeeks.org</a>,
                                        <a href="https://dev.to/devcorner/system-design-roadmap-a-step-by-step-guide-to-mastering-system-design-2647" target="_blank" rel="nofollow noreferrer">dev.to</a>
                                    </li>
                                </ul>
                            </li>
                            <li>
                                <strong>Core Components:</strong>
                                <ul>
                                    <li>Learn the roles of <b>databases, caches, load balancers, and queues</b>.</li>
                                    <li>Understand how a <b>load balancer</b> distributes requests (e.g. round-robin, least-connections)
                                        (<a href="https://designgurus.io" target="_blank" rel="nofollow noreferrer">designgurus.io</a>).</li>
                                    <li>Explore <b>caching</b> for storing hot data for fast access
                                        (<a href="https://www.geeksforgeeks.org/cache-memory-in-computer-organization/" target="_blank" rel="nofollow noreferrer">geeksforgeeks.org</a>).</li>
                                    <li>Study <b>databases</b> (SQL vs NoSQL, indexing, sharding) and <b>messaging systems</b> (RabbitMQ, Kafka, Pub/Sub) for asynchronous processing.
                                        <br>
                                        <a href="https://www.geeksforgeeks.org/sql-vs-nosql/" target="_blank" rel="nofollow noreferrer">SQL vs NoSQL</a>,
                                        <a href="https://www.geeksforgeeks.org/sharding-in-databases/" target="_blank" rel="nofollow noreferrer">Sharding</a>
                                    </li>
                                </ul>
                            </li>
                            <li>
                                <strong>Scalability and Performance:</strong>
                                <ul>
                                    <li>Study <b>vertical vs horizontal scaling</b> and design patterns (sharding, replication).
                                        (<a href="https://www.geeksforgeeks.org/vertical-and-horizontal-scaling/" target="_blank" rel="nofollow noreferrer">geeksforgeeks.org</a>)</li>
                                    <li>Learn <b>caching strategies</b> (in-memory, CDN, cache invalidation) to reduce load.</li>
                                    <li>Practice setting up a basic load-balanced web stack (e.g. Nginx + Redis) to handle more users.</li>
                                    <li>Understand <b>CDNs</b> for static content delivery to reduce latency globally.
                                        (<a href="https://www.geeksforgeeks.org/designing-content-delivery-network-cdn-system-design/" target="_blank" rel="nofollow noreferrer">geeksforgeeks.org</a>)</li>
                                </ul>
                            </li>
                            <li>
                                <strong>Architectural Patterns:</strong>
                                <ul>
                                    <li>Learn <b>monolithic vs microservices architectures</b>.
                                        (<a href="https://www.geeksforgeeks.org/monolithic-vs-microservices-architecture/" target="_blank" rel="nofollow noreferrer">geeksforgeeks.org</a>)</li>
                                    <li>In microservices, break an application into independent services (each with its own API and database).</li>
                                    <li>Study <b>API gateways</b> and <b>service discovery</b> for routing between services.</li>
                                    <li>Explore <b>event-driven architecture</b>: use message queues or publish/subscribe (e.g. Kafka, Google Pub/Sub) for decoupling and asynchronous communication.
                                        (<a href="https://medium.com/@semrush_official/how-to-sync-data-between-different-databases-35c460f4ee63" target="_blank" rel="nofollow noreferrer">medium.com</a>)</li>
                                </ul>
                            </li>
                            <li>
                                <strong>High-Level Design:</strong>
                                <ul>
                                    <li>Practice drawing high-level diagrams (load balancers, clusters, failover).</li>
                                    <li>Deepen understanding of <b>CAP theorem</b> (trade-offs: consistency vs availability), strong vs eventual consistency, and when to prioritize each.
                                        (<a href="https://www.geeksforgeeks.org/tradeoffs-in-system-design/" target="_blank" rel="nofollow noreferrer">geeksforgeeks.org</a>)</li>
                                    <li>Learn about <b>redundancy and failover</b> for availability, and auto-scaling.
                                        (<a href="https://dev.to/navinder/system-architecture-best-practices-designing-robust-and-scalable-systems-3m61" target="_blank" rel="nofollow noreferrer">dev.to</a>)</li>
                                </ul>
                            </li>
                            <li>
                                <strong>Advanced Topics:</strong>
                                <ul>
                                    <li>Study distributed systems principles: <b>consensus</b> (Paxos/Raft), <b>distributed transactions</b> (two-phase commit), and <b>resiliency patterns</b> (circuit breakers, retries).</li>
                                    <li>Learn about <b>monitoring and observability</b>, CI/CD pipelines, and infrastructure as code (e.g. Kubernetes, Terraform).</li>
                                    <li>Explore <b>Big Data tools</b> (Hadoop, Spark, NoSQL stores) and streaming platforms for complex use cases.</li>
                                </ul>
                            </li>
                        </ol>
                    </section>
                    <!-- End Roadmap Section -->

                    <!-- Core Principles of System Design -->
                    <section id="core-principles" class="mb-5">
                        <h2 class="h4 mb-3 text-secondary">Core Principles of System Design</h2>
                        <ul class="list-group list-group-flush">
                            <li class="list-group-item">
                                <strong>Scalability:</strong> The ability to grow and handle increased load without degradation. Design for both horizontal scaling (adding more servers) and vertical scaling (beefing up machines).
                                <br>
                                <a href="https://cybernerdie.medium.com/the-fantastic-four-of-system-design-scalability-availability-reliability-and-performance-ef247cd4bd2c" target="_blank">cybernerdie.medium.com</a>,
                                <a href="https://www.geeksforgeeks.org/tradeoffs-in-system-design/" target="_blank" rel="nofollow noreferrer">geeksforgeeks.org</a>
                                <br>
                                Example: Use sharding to partition a large database across multiple servers (<a href="https://www.geeksforgeeks.org/sharding-in-databases/" target="_blank" rel="nofollow noreferrer">geeksforgeeks.org</a>). Always plan how resources can expand as users grow.
                            </li>
                            <li class="list-group-item">
                                <strong>Availability:</strong> Ensure the system is always up (minimal downtime). Use load balancers and redundancy so that if one component fails, another takes over.
                                <br>
                                <a href="https://designgurus.io" target="_blank" rel="nofollow noreferrer">designgurus.io</a>
                                <br>
                                Example: Duplicate critical servers and use automatic failover. Highly available systems often replicate state and monitor health to reroute traffic on failures.
                            </li>
                            <li class="list-group-item">
                                <strong>Reliability:</strong> The system should consistently deliver correct results.
                                <br>
                                <a href="https://cybernerdie.medium.com/the-fantastic-four-of-system-design-scalability-availability-reliability-and-performance-ef247cd4bd2c" target="_blank" rel="nofollow noreferrer">cybernerdie.medium.com</a>
                                <br>
                                Implement robust error-handling and extensive automated testing to catch bugs before production. Use retries, timeouts, and graceful degradation. Employ thorough monitoring and logging so issues are detected and resolved quickly.
                            </li>
                            <li class="list-group-item">
                                <strong>Performance:</strong> Optimize for fast responses. Use efficient algorithms, database indexing, and caching to reduce latency.
                                <br>
                                <a href="https://cybernerdie.medium.com/the-fantastic-four-of-system-design-scalability-availability-reliability-and-performance-ef247cd4bd2c" target="_blank" rel="nofollow noreferrer">cybernerdie.medium.com</a>
                                <br>
                                Example: Cache hot database queries (via Redis/Memcached) or static content (via a CDN) to serve requests in memory.
                                <br>
                                <a href="https://www.geeksforgeeks.org/designing-content-delivery-network-cdn-system-design/" target="_blank" rel="nofollow noreferrer">geeksforgeeks.org</a>
                                <br>
                                Profile components to find bottlenecks (CPU, I/O, network) and address them iteratively.
                            </li>
                            <li class="list-group-item">
                                <strong>Maintainability:</strong> Design for ease of updates and clarity. Divide the system into modular services (separation of concerns).
                                <br>
                                <a href="https://dev.to/navinder/system-architecture-best-practices-designing-robust-and-scalable-systems-3m61" target="_blank" rel="nofollow noreferrer">dev.to</a>,
                                <a href="https://www.geeksforgeeks.org/tradeoffs-in-system-design/" target="_blank" rel="nofollow noreferrer">geeksforgeeks.org</a>
                                <br>
                                Keep codebases and interfaces simple and well-documented. Adopt version control and coding standards. A maintainable system (like a well-organized LEGO structure) enables new features and fixes with minimal risk.
                            </li>
                        </ul>
                    </section>
                    <!-- End Core Principles Section -->

                    <!-- System Components and Technologies -->
                    <section id="components" class="mb-5">
                        <h2 class="h4 mb-3 text-secondary">System Components and Technologies</h2>
                        <div class="accordion" id="componentsAccordion">
                            <div class="accordion-item">
                                <h2 class="accordion-header" id="headingLoadBalancers">
                                    <button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapseLoadBalancers" aria-expanded="true" aria-controls="collapseLoadBalancers">
                                        Load Balancers
                                    </button>
                                </h2>
                                <div id="collapseLoadBalancers" class="accordion-collapse collapse show" aria-labelledby="headingLoadBalancers" data-bs-parent="#componentsAccordion">
                                    <div class="accordion-body">
                                        <p>
                                            A load balancer routes incoming client requests to multiple backend servers, preventing any one server from overloading.
                                            <br>
                                            <a href="https://www.designgurus.io/course-play/grokking-system-design-fundamentals/doc/introduction-to-load-balancing" target="_blank" rel="nofollow noreferrer">designgurus.io: Introduction to Load Balancing</a>
                                        </p>
                                        <ul>
                                            <li>
                                                <strong>Function:</strong> Load balancers sit between clients and server clusters, distributing traffic according to algorithms (round-robin, least-connections, etc.). By balancing requests, they avoid single points of failure and improve overall throughput and availability.
                                            </li>
                                            <li>
                                                <strong>Common Strategies:</strong> Health checks (removing unhealthy servers), SSL/TLS termination at the LB to offload encryption.
                                            </li>
                                            <li>
                                                <strong>Placement:</strong> Often placed at multiple tiers: between clients and web servers, between web and app servers, or between app servers and databases. Multi-tier LBs enable full redundancy.
                                            </li>
                                            <li>
                                                <strong>Algorithms:</strong> Choices include round-robin, random, least-connections, IP-hash, etc. Each request is forwarded based on capacity and current load.
                                            </li>
                                            <li>
                                                <strong>Session Persistence:</strong> Also called sticky sessions; can bind a user’s session to one server. Useful for stateful apps, but adds a single-point-of-failure risk for that session.
                                            </li>
                                            <li>
                                                <strong>Redundancy:</strong> LBs themselves should be replicated (e.g. an active-passive pair or DNS-based multi-LB) to avoid making the load balancer a bottleneck.
                                            </li>
                                        </ul>
                                    </div>
                                </div>
                            </div>
                            <div class="accordion-item">
                                <h2 class="accordion-header" id="headingCaching">
                                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseCaching" aria-expanded="false" aria-controls="collapseCaching">
                                        Caching
                                    </button>
                                </h2>
                                <div id="collapseCaching" class="accordion-collapse collapse" aria-labelledby="headingCaching" data-bs-parent="#componentsAccordion">
                                    <div class="accordion-body">
                                        <p>
                                            Caching stores frequently accessed data in a fast-access layer (often in-memory) to improve performance and reduce backend load.
                                            <br>
                                            <a href="https://www.geeksforgeeks.org/caching-system-design-concept-for-beginners/" target="_blank" rel="nofollow noreferrer">geeksforgeeks.org: Caching System Design Concept</a>
                                        </p>
                                        <ul>
                                            <li>
                                                <strong>How it works:</strong> Instead of querying the database for every request, hot data (like popular user profiles) is kept in a cache (e.g., Redis). This reduces database load and speeds up responses.
                                                <br>
                                                <em>Figure: Without caching (top), a student fetches Book 4 by scanning a tall shelf (slow). With caching (bottom), commonly read books (like Book 4) are on a table (“cache”), making access faster.</em>
                                            </li>
                                            <li>
                                                <strong>Types of Cache:</strong> 
                                                <ul>
                                                    <li>In-memory caches (Redis, Memcached) beside the app or DB</li>
                                                    <li>CDN caches at network edges for static assets</li>
                                                    <li>Browser caches on the client</li>
                                                </ul>
                                            </li>
                                            <li>
                                                <strong>Eviction/Expiration:</strong> Cached data may become stale. Use eviction policies (e.g., LRU – least recently used) and TTLs (time-to-live) to refresh data. Cache invalidation is challenging—ensure updates propagate (e.g., purge or update cache on writes).
                                            </li>
                                            <li>
                                                <strong>Use Cases:</strong> Session storage, query results, computed views, or full HTML pages. Caching query results prevents expensive DB lookups.
                                            </li>
                                            <li>
                                                <strong>Cache Hierarchy:</strong> Combine caches for best effect: e.g., application-level cache (Redis) for dynamic queries, plus a CDN for static content.
                                            </li>
                                        </ul>
                                    </div>
                                </div>
                            </div>
                            <div class="accordion-item">
                                <h2 class="accordion-header" id="headingDatabases">
                                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseDatabases" aria-expanded="false" aria-controls="collapseDatabases">
                                        Databases (Storage)
                                    </button>
                                </h2>
                                <div id="collapseDatabases" class="accordion-collapse collapse" aria-labelledby="headingDatabases" data-bs-parent="#componentsAccordion">
                                    <div class="accordion-body">
                                        <p>
                                            Databases store application state and are central to system design. Choose between SQL (e.g., MySQL, PostgreSQL) and NoSQL (e.g., MongoDB, Cassandra) based on access patterns and scalability needs.
                                            <br>
                                            <a href="https://www.geeksforgeeks.org/database-sharding-a-system-design-concept/" target="_blank" rel="nofollow noreferrer">geeksforgeeks.org: Database Sharding</a>
                                        </p>
                                        <ul>
                                            <li>
                                                <strong>SQL vs NoSQL:</strong> SQL databases use rigid schemas and ACID transactions, ideal for structured data and strong consistency. NoSQL databases are schema-less, horizontally scalable, and often favor availability and partition tolerance.
                                            </li>
                                            <li>
                                                <strong>Replication:</strong> Keep multiple copies (master-slave or multi-master) to improve read performance and fault tolerance. One primary handles writes, secondaries replicate data for reads.
                                            </li>
                                            <li>
                                                <strong>Sharding:</strong> Split large tables/collections by key range or hash. Each shard holds a subset of data, allowing each server to handle less load and improving throughput.
                                                <br>
                                                <em>Figure: Database sharding for horizontal scaling. Top: a single data server. Bottom: data split into Shard 1 and Shard 2 across two servers.</em>
                                            </li>
                                            <li>
                                                <strong>Indexes:</strong> Create indices on database fields to accelerate queries (trading space for speed). Proper indexing is critical for query performance.
                                            </li>
                                            <li>
                                                <strong>Consistency vs Availability:</strong> In distributed DBs, a trade-off exists (CAP theorem). Some NoSQL stores sacrifice immediate consistency for higher availability (eventual consistency). Choose model per needs (e.g., financial data requires strong consistency, social feed may allow eventual consistency).
                                            </li>
                                            <li>
                                                <strong>Backup and Shard Management:</strong> Always backup critical data. Plan shard rebalancing strategies if data grows unevenly.
                                            </li>
                                        </ul>
                                    </div>
                                </div>
                            </div>
                            <div class="accordion-item">
                                <h2 class="accordion-header" id="headingMessageQueues">
                                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseMessageQueues" aria-expanded="false" aria-controls="collapseMessageQueues">
                                        Message Queues (Asynchronous Messaging)
                                    </button>
                                </h2>
                                <div id="collapseMessageQueues" class="accordion-collapse collapse" aria-labelledby="headingMessageQueues" data-bs-parent="#componentsAccordion">
                                    <div class="accordion-body">
                                        <p>
                                            Message queues enable asynchronous communication between services by decoupling producers and consumers.
                                            <br>
                                            <a href="https://www.geeksforgeeks.org/message-queues-system-design/" target="_blank" rel="nofollow noreferrer">geeksforgeeks.org: Message Queues System Design</a>
                                        </p>
                                        <ul>
                                            <li>
                                                <strong>How it works:</strong> A producer puts messages (tasks or events) onto a queue; a consumer retrieves them when ready. This decouples services—producers don’t wait for consumers, and systems can buffer bursts of load.
                                                <br>
                                                <em>Figure: A message queue decouples a producer and a consumer. The producer (left) sends an envelope (message) to the queue (center), and the consumer (right) reads it later.</em>
                                            </li>
                                            <li>
                                                <strong>Benefits:</strong> Improves fault tolerance (if a consumer is down, messages wait safely) and allows parallel processing by multiple consumers.
                                            </li>
                                            <li>
                                                <strong>Pub/Sub vs Queue:</strong> In a simple queue, one consumer takes each message. In a publish/subscribe system, messages (events) are broadcast to all subscribers (fan-out). Pub/Sub (Kafka, Google Pub/Sub) is ideal for event-driven architectures.
                                            </li>
                                            <li>
                                                <strong>Durability:</strong> Queues often persist messages to disk until consumed (to survive crashes). Durable queues ensure no data loss.
                                            </li>
                                            <li>
                                                <strong>Ordering:</strong> Some systems guarantee FIFO ordering, others do not. Choose based on needs.
                                            </li>
                                            <li>
                                                <strong>Dead-Letter Queues:</strong> Unprocessed or error messages can be routed to a dead-letter queue for inspection and reprocessing.
                                            </li>
                                            <li>
                                                <strong>Examples:</strong> Popular queue systems include RabbitMQ, Apache Kafka, Amazon SQS, Google Pub/Sub, Redis Streams, etc.
                                            </li>
                                        </ul>
                                    </div>
                                </div>
                            </div>
                            <div class="accordion-item">
                                <h2 class="accordion-header" id="headingMicroservices">
                                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseMicroservices" aria-expanded="false" aria-controls="collapseMicroservices">
                                        Microservices Architecture
                                    </button>
                                </h2>
                                <div id="collapseMicroservices" class="accordion-collapse collapse" aria-labelledby="headingMicroservices" data-bs-parent="#componentsAccordion">
                                    <div class="accordion-body">
                                        <p>
                                            In a microservices architecture, the application is split into many small, loosely-coupled services, each responsible for a single business function.
                                            <br>
                                            <a href="https://www.geeksforgeeks.org/microservices/" target="_blank" rel="nofollow noreferrer">geeksforgeeks.org: Microservices</a>
                                        </p>
                                        <ul>
                                            <li>
                                                <strong>How it works:</strong> Each service runs independently (often in its own process or container) and communicates with others over network APIs (REST/gRPC) via a common API Gateway or service mesh.
                                                <br>
                                                <em>Figure: An API Gateway routes client (mobile/web) requests to independent services (Account, Inventory, Shipping), each with its own database.</em>
                                            </li>
                                            <li>
                                                <strong>API Gateway:</strong> A central entry point that routes external requests to the correct microservice. Handles cross-cutting concerns (auth, rate limiting, SSL) and exposes a unified interface.
                                            </li>
                                            <li>
                                                <strong>Service Discovery:</strong> Services register themselves, and clients/gateways discover service locations dynamically (via DNS or service registry).
                                            </li>
                                            <li>
                                                <strong>Data Management:</strong> Each microservice owns its data. Cross-service joins are avoided; data is shared via APIs or events.
                                            </li>
                                            <li>
                                                <strong>Scaling:</strong> Services scale horizontally (add more instances) to handle load. Stateless services scale more easily; stateful data is handled by dedicated databases or caches.
                                            </li>
                                            <li>
                                                <strong>Trade-offs:</strong> Microservices improve flexibility and maintainability by isolating services, but add complexity (network calls, distributed debugging). Monolithic systems are simpler initially but can become unwieldy as they grow.
                                            </li>
                                        </ul>
                                    </div>
                                </div>
                            </div>
                            <div class="accordion-item">
                                <h2 class="accordion-header" id="headingAPIs">
                                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseAPIs" aria-expanded="false" aria-controls="collapseAPIs">
                                        APIs and Integration
                                    </button>
                                </h2>
                                <div id="collapseAPIs" class="accordion-collapse collapse" aria-labelledby="headingAPIs" data-bs-parent="#componentsAccordion">
                                    <div class="accordion-body">
                                        <p>
                                            APIs define how clients and services communicate. Common patterns include REST/HTTP (resource-based endpoints with JSON) and GraphQL (client-driven queries over a single endpoint).
                                        </p>
                                        <ul>
                                            <li>
                                                <strong>Design:</strong> Use clear, versioned API designs. Document APIs using OpenAPI/Swagger for easy integration.
                                            </li>
                                            <li>
                                                <strong>Security:</strong> Enforce authentication/authorization (OAuth2, JWT) at the gateway or service level.
                                            </li>
                                            <li>
                                                <strong>Rate Limiting:</strong> Implement rate limiting and throttling on APIs to prevent abuse.
                                            </li>
                                            <li>
                                                <strong>Inter-service Communication:</strong> For microservices, use lightweight protocols like gRPC (with protobuf) for efficient inter-service calls.
                                            </li>
                                        </ul>
                                    </div>
                                </div>
                            </div>
                            <div class="accordion-item">
                                <h2 class="accordion-header" id="headingCDN">
                                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseCDN" aria-expanded="false" aria-controls="collapseCDN">
                                        Content Delivery Networks (CDNs)
                                    </button>
                                </h2>
                                <div id="collapseCDN" class="accordion-collapse collapse" aria-labelledby="headingCDN" data-bs-parent="#componentsAccordion">
                                    <div class="accordion-body">
                                        <p>
                                            A CDN is a globally distributed caching network for static (and some dynamic) content.
                                            <br>
                                            <a href="https://www.geeksforgeeks.org/designing-content-delivery-network-cdn-system-design/" target="_blank" rel="nofollow noreferrer">geeksforgeeks.org: Designing Content Delivery Network (CDN)</a>
                                        </p>
                                        <ul>
                                            <li>
                                                <strong>How it works:</strong> The origin server holds master copies of files (images, videos, scripts), while edge servers around the world cache copies. User requests are routed to the nearest edge, minimizing travel time.
                                                <br>
                                                <em>Figure: A CDN with one origin server (green) and multiple edge servers (black). User requests are served by the nearest edge, reducing latency.</em>
                                            </li>
                                            <li>
                                                <strong>Operation:</strong> On first request, an edge server fetches content from the origin and caches it; subsequent requests are served locally.
                                            </li>
                                            <li>
                                                <strong>Use Cases:</strong> Ideal for static assets (HTML, CSS, JS, images, videos), large-scale downloads, streaming media, and large file delivery.
                                            </li>
                                            <li>
                                                <strong>Benefits:</strong> CDNs reduce latency (faster user experience) and offload traffic from the origin server, improving availability during traffic spikes. They also often provide DDoS protection and SSL offloading.
                                            </li>
                                            <li>
                                                <strong>Example Providers:</strong> Akamai, Cloudflare, Fastly, AWS CloudFront, Google Cloud CDN, etc.
                                            </li>
                                        </ul>
                                    </div>
                                </div>
                            </div>
                            <div class="accordion-item">
                                <h2 class="accordion-header" id="headingMonitoring">
                                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseMonitoring" aria-expanded="false" aria-controls="collapseMonitoring">
                                        Monitoring & Logging
                                    </button>
                                </h2>
                                <div id="collapseMonitoring" class="accordion-collapse collapse" aria-labelledby="headingMonitoring" data-bs-parent="#componentsAccordion">
                                    <div class="accordion-body">
                                        <!-- ...existing Monitoring & Logging content... -->
                                    </div>
                                </div>
                            </div>
                            <div class="accordion-item">
                                <h2 class="accordion-header" id="headingIaC">
                                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseIaC" aria-expanded="false" aria-controls="collapseIaC">
                                        Infrastructure as Code
                                    </button>
                                </h2>
                                <div id="collapseIaC" class="accordion-collapse collapse" aria-labelledby="headingIaC" data-bs-parent="#componentsAccordion">
                                    <div class="accordion-body">
                                        <!-- ...existing Infrastructure as Code content... -->
                                    </div>
                                </div>
                            </div>
                        </div>
                    </section>
                    <!-- End System Components and Technologies -->
                </article>
            </section>
        </div>
    </main>

    <footer loadhtml="https://brijesh.work/pub/inc/footer.html" class="bg-white shadow-sm" role="contentinfo"></footer>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script>includeHTML();</script>
    <style>
        body {
            background: #f8f9fa;
            font-size: 1.08rem;
            font-family: 'Segoe UI', 'Roboto', Arial, sans-serif;
            line-height: 1.75;
            letter-spacing: 0.01em;
        }
        .tutorial-section {
            background: #fff;
            border-radius: 12px;
            box-shadow: 0 2px 16px rgba(0,0,0,0.06);
            font-size: 1.08rem;
            line-height: 1.75;
            letter-spacing: 0.01em;
        }
        .section-title {
            font-size: 2.3rem;
            font-weight: 700;
            color: #0d6efd;
            letter-spacing: -1px;
        }
        .h4, h2.h4 {
            font-size: 1.35rem;
            font-weight: 600;
            letter-spacing: 0.01em;
        }
        .accordion-button:not(.collapsed) {
            color: #0d6efd;
            background-color: #e7f1ff;
        }
        .accordion-button {
            font-weight: 500;
            font-size: 1.08rem;
            letter-spacing: 0.01em;
        }
        .accordion-body ul {
            margin-bottom: 0;
            font-size: 1.04rem;
            line-height: 1.7;
            letter-spacing: 0.01em;
        }
        .list-group-item {
            border: none;
            padding-left: 0;
            font-size: 1.07rem;
            line-height: 1.7;
            letter-spacing: 0.01em;
        }
        .nav-link.active, .nav-link:focus, .nav-link:hover {
            color: #0d6efd;
            background: #e7f1ff;
        }
        .card-title {
            font-size: 1.1rem;
            font-weight: 600;
            letter-spacing: 0.01em;
        }
        .nav.flex-column .nav-link {
            font-size: 1.01rem;
            letter-spacing: 0.01em;
        }
        @media (max-width: 991.98px) {
            aside {
                position: static !important;
                margin-bottom: 2rem;
            }
            .section-title {
                font-size: 1.5rem;
            }
        }
    </style>
</body>
</html>